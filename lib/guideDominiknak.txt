Ha barmit nem tudsz ugy megoldani, ahogy en elkepzeltem, vagy ilyesmi, akkor mondd :D

FONTOS: atirtam a usernek a productsBought (1) es a productnak a peopleBuying (2) properyjet, mindketto Map<int,int>
(1) key-je a productId, value-ja, hogy abbol hanyat vett eddig osszesen
(2) key-je a userId, value-ja, hogy az a user hanyat vett eddig osszesen
Szerintem ezt egy az egyben at tudod adni.

// users get
http.Response response =
    await httpGet(context: context, uri: generateUri(GetUriKeys.users));
List<Map<String, dynamic>> decoded = jsonDecode(response.body);
List<User> users = [];
for (Map<String, dynamic> decodedUser in decoded) {
User user = User(
    decodedUser['id'],
    decodedUser['name'],
    decodedUser['balance'],
    createdAt: DateTime.parse(decodedUser['created_at']),
    updatedAt: DateTime.parse(decodedUser['updated_at']),
);
user.productsBought = decodedUser['products_bought'];
users.add(user);
}
return users;

// drinks get
http.Response response =
        await httpGet(context: context, uri: generateUri(GetUriKeys.drinks));
    List<Map<String, dynamic>> decoded = jsonDecode(response.body);
    List<Product> products = [];
    for (Map<String, dynamic> decodedProduct in decoded) {
    Product product = Product(
        decodedProduct['name'],
        decodedProduct['price'],
        productTypeFromString(decodedProduct['type']),
        id: decodedProduct['id'],
        createdAt: DateTime.parse(decodedProduct['created_at']),
        updatedAt: DateTime.parse(decodedProduct['updated_at']),
    );
    product.peopleBuying = decodedProduct['people_buying'];
    products.add(product);
    }
    return products;
} catch (_) {
    throw _;
}

// history get -> itt egyszerre szuksegem van a userekre, a productokra meg a purchasekre is, mert mindenhonnan kell valami info
// (usernek a neve, productnak a neve, meg hogy mennyibe kerul)
// itt fog kelleni egy tol-ig idolekerdezes, azt meg nem csinaltam meg
// plusz pl meno lenne, ha egyes usereknek is le lehetne kerni a statisztikait, az sincs meg meg, de gondolom ki tudod gondolni
// aztan ott alkalmazkodom hozzad :D

http.Response response =
  await httpGet(context: context, uri: generateUri(GetUriKeys.history));
Map<String, List<Map<String, dynamic>>> decoded =
  jsonDecode(response.body);
List<Product> products = [];
if (decoded['products'] != null) {
for (Map<String, dynamic> decodedProduct in decoded['products']!) {
  Product product = Product(
    decodedProduct['name'],
    decodedProduct['price'],
    productTypeFromString(decodedProduct['type']),
    id: decodedProduct['id'],
    createdAt: DateTime.parse(decodedProduct['created_at']),
    updatedAt: DateTime.parse(decodedProduct['updated_at']),
  );
  product.peopleBuying = decodedProduct['people_buying'];
  products.add(product);
}
} else {
throw 'null on products';
}
List<User> users = [];
if (decoded['users'] != null) {
for (Map<String, dynamic> decodedUser in decoded['users']!) {
  User user = User(
    decodedUser['id'],
    decodedUser['name'],
    decodedUser['balance'],
    createdAt: DateTime.parse(decodedUser['created_at']),
    updatedAt: DateTime.parse(decodedUser['updated_at']),
  );
  user.productsBought = decodedUser['products_bought'];
  users.add(user);
}
} else {
throw 'null on users';
}
List<Purchase> purchases = [];
if (decoded['purchases'] != null) {
for (Map<String, dynamic> decodedPurchase in decoded['purchases']!) {
  Purchase purchase = Purchase(
    id: decodedPurchase['id'],
    userId: decodedPurchase['userId'],
    productId: decodedPurchase['productId'],
    amount: decodedPurchase['amount'],
    createdAt: DateTime.parse(decodedPurchase['created_at']),
    updatedAt: DateTime.parse(decodedPurchase['updated_at']),
  );
  purchases.add(purchase);
}
} else {
throw 'null on purchases';
}

return [users, purchases, products];

//user update -> balance
//itt figyelj arra, hogy a balance valtoztatast mentsd el purchasekent is (itt beszeltuk, hogy a productId -1 legyen)

Map<String, dynamic> body = {
  'balance_to_add': balance,
};
await httpPut(
    context: context,
    uri: '/user/' + selectedUser!.id.toString(),
    body: body);

//purchases post -> ez ahol megveszi a cuccokat
//nem tudom nalad ez hogy van, de majd ugye ez alapjan tudod visszaadni mashol, hogy a user mennyit vett eddig adott dologbol meg ilyesmi
//meg ugye itt akkor most az a policy, hogy kulon-kulon kell elmenteni soronkent, ha tobbfele product van (meg minden sorban ott van, hogy mennyi
//volt belole)
//aztan en az elozmenyeknel ebbol ugy csinalok egy vasarlast, hogy azt mondom, hogy azok a purchasek egy vasarlas,
//amit ugyanaz a user csinalt 1 masodpercen belul

Map<String, dynamic> body = {
  'user_id': widget.user.id,
  'product_ids': productsToBuy.keys.map((e) => e.id).toList(),
};
httpPost(context: context, uri: '/purchases', body: body);

//product update
//itt a type mezoben egy stringet adok vissza, meg tudod nezni, hogy miket varok meg adok meg
//a product.dart fajlban (van ket function, az egyik odafele, a masik visszafele alakitja az enumot)

Map<String, dynamic> body = {
    'name': name,
    'price': price,
    'type': generateProductTypeString(typeDropdownValue!),
  };
  await httpPut(
    context: context,
    uri: '/product/' + selectedProduct!.id.toString(),
    body: body,
  );
  Future.delayed(Duration(milliseconds: 300))
      .then((value) => _onUpdateProduct());
  return true;
} catch (_) {
  throw _;
}

//user post
Map<String, dynamic> body = {
  'name': name,
  'id': id,
};
await httpPost(context: context, uri: '/users', body: body);